<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-apis/google-maps-api.html">

<!--
`geo-codec`
Easily do geocoding and reverse geocoding with the Google maps API.
@demo demo/index.html
-->

<dom-module id="geo-codec">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <google-maps-api
      id="api"
      api-key="[[apiKey]]"
      version="3.exp">
    </google-maps-api>
  </template>

  <script>
    Polymer({

      is: 'geo-codec',

      properties: {
        /**
         * Your Google maps API key. See https://developers.google.com/maps/documentation/javascript/get-api-key
         */
        apiKey: String,

        /**
         * True when the Google maps API has been loaded. You can also listen for the `api-loaded` event.
         * Attempts to use the geocoder before it is ready will be queued and executed when ready.
         */
        isLoaded: {
          type: Boolean,
          value: false,
          readOnly: true
        }
      },

      /**
       * The `google.maps.Geocoder` instance.
       */
      get geocoder() {
        this.geocoderInstance = this.geocoderInstance || new google.maps.Geocoder();
        return this.geocoderInstance;
      },

      ready: function() {
        this.$.api.addEventListener('api-load', function(e) {
          this._setIsLoaded(true);
          if (this.queue) {
            for (var i = 0; i < this.queue.length; i++) {
              this.queue[i]();
            }
          }
        }.bind(this));
      },

      /**
       * Convert an address into coordinates.
       *
       * `address`: The string to geocode.
       *
       * `onComplete`: A callback function with arguments (*formatted address*, *lat*, *lng*, *place_id*).
       *              If the geocoder fails, a console warning is emitted and all arguments will be undefined.
       */
      geocode: function(address, onComplete) {
        if (!this.isLoaded) {
          this.__addToQueue(this.geocode, this, arguments);
          return;
        }
        this.geocoder.geocode({address: address}, function(results, status) {
//                    console.log(address, status, results);
          if (status == google.maps.GeocoderStatus.OK && results[0]) {
            onComplete(
                    results[0].formatted_address,           // address
                    results[0].geometry.location.lat(),     // lat
                    results[0].geometry.location.lng(),     // lng
                    results[0].place_id);                   // place id
          } else {
            console.warn('Geocode failed for ' + address + '. Status ' + status, results);
            onComplete();
          }
        });
      },

      /**
       * Convert coordinates into an address.
       *
       * `lat`: Latitude
       *
       * `lng`: Longitude
       *
       * `precise`: If true, attempts to get the street address as part of the location.
       *            If false, will only get the general area (e.g. city).
       *
       * `onComplete`: A callback function with arguments (*formatted address*, *address components*, *place_id*).
       *              If the geocoder fails, a console warning is emitted and all arguments will be undefined.
       */
      reverseGeocode: function(lat, lng, precise, onComplete) {
        if (!this.isLoaded) {
          this.__addToQueue(this.reverseGeocode, this, arguments);
          return;
        }
        this.geocoder.geocode({location: {lat: lat, lng: lng}}, function(results, status) {
//                    console.log(lat, lng, precise, status, results);
          if (status == google.maps.GeocoderStatus.OK && (precise || results[1])) {
            var index = precise ? 0 : 1;
            onComplete(
                    results[index].formatted_address,           // address
                    results[index].address_components,          // components
                    results[index].place_id);                   // place
          } else {
            console.warn('Geocode failed for [' + lat + ',' + lng + ']. Status ' + status, results);
            onComplete();
          }
        });
      },

      /**
       * Convert a place_id into an address and coordinates.
       *
       * `placeId`: The place_id to reverse geocode.
       *
       * `onComplete`: A callback function with arguments (*formatted address*, *address components*, *lat*, *lng*).
       *              If the geocoder fails, a console warning is emitted and all arguments will be undefined.
       */
      reverseGeocodePlace: function(placeId, onComplete) {
        if (!this.isLoaded) {
          this.__addToQueue(this.reverseGeocodePlace, this, arguments);
          return;
        }
        this.geocoder.geocode({'placeId': placeId}, function(results, status) {
//                    console.log(placeId, status, results);
          if (status == google.maps.GeocoderStatus.OK && results[0]) {
            onComplete(
                    results[0].formatted_address,           // address
                    results[0].address_components,          // components
                    results[0].geometry.location.lat(),     // lat
                    results[0].geometry.location.lng());    // lng
          } else {
            console.warn('Geocode failed for ' + placeId + '. Status ' + status, results);
            onComplete();
          }
        });
      },

      __addToQueue: function(fun, ctx, args) {
//        console.log('adding to queue');
        this.queue = this.queue || [];
        this.queue.push(function() {
          console.log(fun, ctx, args);
          fun.apply(ctx, args);
        });
      }
    });
  </script>
</dom-module>
